// èŠå¤©æœåŠ¡ - å¤„ç† API è¯·æ±‚
import { http } from '@kit.NetworkKit';
import { Message, StreamChunk } from '../models/ChatModels';
import { ApiConfig } from '../config/ApiConfig';

export class ChatService {
  private baseUrl: string = ApiConfig.getBaseUrl();

  /**
   * å‘é€èŠå¤©æ¶ˆæ¯ï¼ˆæµå¼ï¼‰
   */
  async sendMessage(
    message: string,
    history: Message[],
    mode: string,
    onChunk: (chunk: StreamChunk) => void,
    onComplete: () => void,
    onError: (error: string) => void
  ): Promise<void> {
    console.info('=== ChatService.sendMessage å¼€å§‹ ===');
    console.info('[ChatService] æ¶ˆæ¯:', message);
    console.info('[ChatService] æ¨¡å¼:', mode);
    console.info('[ChatService] å†å²è®°å½•æ•°:', history.length);
    
    let httpRequest: http.HttpRequest | null = null;
    let hasCompleted = false;
    let buffer = '';
    
    try {
      console.info('[ChatService] åˆ›å»º HTTP è¯·æ±‚...');
      httpRequest = http.createHttp();
      console.info('[ChatService] HTTP è¯·æ±‚åˆ›å»ºæˆåŠŸ');
      
      // æ„å»ºè¯·æ±‚ä½“
      interface HistoryItem {
        role: string;
        content: string;
        name?: string;
      }
      
      interface RequestBody {
        message: string;
        history: HistoryItem[];
        mode: string;
      }
      
      const requestBody: RequestBody = {
        message: message,
        history: history.map((msg: Message): HistoryItem => ({
          role: msg.role,
          content: msg.content,
          name: msg.name
        })),
        mode: mode
      };

      const url = `${this.baseUrl}/api/chat/stream`;
      console.info(`[ChatService] ç›®æ ‡ URL: ${url}`);
      console.info(`[ChatService] è¯·æ±‚ä½“:`, JSON.stringify(requestBody));

      // æ³¨å†Œäº‹ä»¶ç›‘å¬å™¨
      console.info('[ChatService] æ³¨å†Œäº‹ä»¶ç›‘å¬å™¨...');
      
      httpRequest.on('headersReceive', (header) => {
        console.info('[ChatService] âœ… æ”¶åˆ°å“åº”å¤´:', JSON.stringify(header));
      });

      // å¤„ç†æµå¼å“åº”
      httpRequest.on('dataReceive', (data: ArrayBuffer) => {
        console.info('[ChatService] ğŸ“¥ dataReceive äº‹ä»¶è§¦å‘ï¼');
        try {
          const text = this.arrayBufferToString(data);
          console.info('[ChatService] æ•°æ®å—é•¿åº¦:', data.byteLength);
          console.info('[ChatService] æ•°æ®å†…å®¹:', text.substring(0, 200));
          
          // å°†æ–°æ•°æ®è¿½åŠ åˆ°ç¼“å†²åŒº
          buffer += text;
          
          // æŒ‰è¡Œå¤„ç†
          const lines = buffer.split('\n');
          // ä¿ç•™æœ€åä¸€ä¸ªä¸å®Œæ•´çš„è¡Œ
          buffer = lines.pop() || '';
          
          for (const line of lines) {
            if (line.startsWith('data: ')) {
              const dataStr = line.substring(6).trim();
              if (dataStr === '[DONE]') {
                if (!hasCompleted) {
                  hasCompleted = true;
                  console.info('[ChatService] Stream completed with [DONE]');
                  onComplete();
                }
                return;
              }
              
              if (dataStr) {
                try {
                  const chunk: StreamChunk = JSON.parse(dataStr);
                  console.info('[ChatService] Parsed chunk:', JSON.stringify(chunk));
                  onChunk(chunk);
                } catch (e) {
                  console.error('[ChatService] Parse chunk error:', e, 'Data:', dataStr);
                }
              }
            }
          }
        } catch (e) {
          console.error('[ChatService] DataReceive error:', e);
        }
      });

      httpRequest.on('dataEnd', () => {
        console.info('[ChatService] âœ… dataEnd äº‹ä»¶è§¦å‘');
        if (!hasCompleted) {
          hasCompleted = true;
          console.info('[ChatService] è°ƒç”¨ onComplete');
          onComplete();
        }
        if (httpRequest) {
          httpRequest.destroy();
          console.info('[ChatService] HTTP è¯·æ±‚å·²é”€æ¯');
        }
      });
      
      httpRequest.on('dataReceiveProgress', (dataProgress: object) => {
        console.info('[ChatService] ğŸ“Š dataReceiveProgress:', JSON.stringify(dataProgress));
      });
      
      console.info('[ChatService] äº‹ä»¶ç›‘å¬å™¨æ³¨å†Œå®Œæˆ');

      // å‘é€è¯·æ±‚
      console.info('[ChatService] ğŸš€ å‘é€ HTTP è¯·æ±‚...');
      const requestPromise = httpRequest.request(
        url,
        {
          method: http.RequestMethod.POST,
          header: {
            'Content-Type': 'application/json',
            'Accept': 'text/event-stream'
          },
          extraData: JSON.stringify(requestBody),
          expectDataType: http.HttpDataType.STRING,
          connectTimeout: ApiConfig.TIMEOUT.CONNECT,
          readTimeout: ApiConfig.TIMEOUT.READ
        },
        (err, data) => {
          if (err) {
            console.error('[ChatService] âŒ è¯·æ±‚é”™è¯¯');
            console.error('[ChatService] é”™è¯¯å¯¹è±¡:', JSON.stringify(err));
            console.error('[ChatService] é”™è¯¯ç :', err.code);
            console.error('[ChatService] é”™è¯¯ä¿¡æ¯:', err.message);
            if (!hasCompleted) {
              hasCompleted = true;
              // æä¾›æ›´å‹å¥½çš„é”™è¯¯ä¿¡æ¯
              let errorMsg = 'ç½‘ç»œè¯·æ±‚å¤±è´¥';
              if (err.code === 2300003) {
                errorMsg = 'æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œè¯·æ£€æŸ¥ï¼š\n1. åç«¯æœåŠ¡æ˜¯å¦å¯åŠ¨\n2. ç½‘ç»œé…ç½®æ˜¯å¦æ­£ç¡®\n3. æ¨¡æ‹Ÿå™¨ä½¿ç”¨ 10.0.2.2ï¼ŒçœŸæœºä½¿ç”¨ç”µè„‘IP';
              } else if (err.message) {
                errorMsg = err.message;
              }
              onError(errorMsg);
            }
            if (httpRequest) {
              httpRequest.destroy();
            }
            return;
          }
          
          console.info('[ChatService] âœ… æ”¶åˆ°å“åº”ï¼ŒçŠ¶æ€ç :', data.responseCode);
          
          // æ£€æŸ¥å“åº”çŠ¶æ€
          if (data && data.responseCode !== 200) {
            console.error('[ChatService] âŒ å“åº”é”™è¯¯ï¼ŒçŠ¶æ€ç :', data.responseCode);
            console.error('[ChatService] å“åº”å†…å®¹:', data.result);
            if (!hasCompleted) {
              hasCompleted = true;
              onError(`æœåŠ¡å™¨é”™è¯¯: ${data.responseCode}`);
            }
            if (httpRequest) {
              httpRequest.destroy();
            }
            return;
          }
          
          // HarmonyOS ä¼šæŠŠæ‰€æœ‰æµå¼æ•°æ®ç¼“å­˜åœ¨ result ä¸­
          if (data.result && typeof data.result === 'string') {
            console.info('[ChatService] ğŸ“¦ ä» result ä¸­è§£ææ•°æ®ï¼Œé•¿åº¦:', data.result.length);
            
            try {
              // è§£ææ‰€æœ‰æ•°æ®
              const lines = data.result.split('\n');
              
              for (const line of lines) {
                if (line.startsWith('data: ')) {
                  const dataStr = line.substring(6).trim();
                  
                  if (dataStr === '[DONE]') {
                    console.info('[ChatService] è§£æå®Œæˆ [DONE]');
                    continue;
                  }
                  
                  if (dataStr) {
                    try {
                      const chunk: StreamChunk = JSON.parse(dataStr);
                      console.info('[ChatService] è§£æ chunk:', chunk.type);
                      onChunk(chunk);
                    } catch (e) {
                      console.error('[ChatService] è§£æ chunk å¤±è´¥:', e, 'Data:', dataStr);
                    }
                  }
                }
              }
              
              // æ‰€æœ‰æ•°æ®å¤„ç†å®Œæˆ
              if (!hasCompleted) {
                hasCompleted = true;
                console.info('[ChatService] æ‰€æœ‰æ•°æ®å¤„ç†å®Œæˆï¼Œè°ƒç”¨ onComplete');
                onComplete();
              }
            } catch (e) {
              console.error('[ChatService] è§£æ result å¤±è´¥:', e);
              if (!hasCompleted) {
                hasCompleted = true;
                onError('è§£æå“åº”æ•°æ®å¤±è´¥');
              }
            }
            
            if (httpRequest) {
              httpRequest.destroy();
            }
          }
        }
      );
    } catch (error) {
      console.error('[ChatService] âŒ å‘é€æ¶ˆæ¯å¼‚å¸¸:', error);
      console.error('[ChatService] å¼‚å¸¸è¯¦æƒ…:', JSON.stringify(error));
      if (!hasCompleted) {
        hasCompleted = true;
        onError('å‘é€æ¶ˆæ¯å¤±è´¥: ' + error);
      }
      if (httpRequest) {
        httpRequest.destroy();
      }
    }
    console.info('=== ChatService.sendMessage ç»“æŸ ===');
  }

  private arrayBufferToString(buffer: ArrayBuffer): string {
    const uint8Array = new Uint8Array(buffer);
    let result = '';
    for (let i = 0; i < uint8Array.length; i++) {
      result += String.fromCharCode(uint8Array[i]);
    }
    return result;
  }
}

export default new ChatService();
